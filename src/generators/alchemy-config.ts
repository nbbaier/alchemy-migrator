import type { AlchemyConfig, AlchemyResource, AlchemyWorker } from '../types/alchemy.js';
import { TypeScriptBuilder } from '../utils/ast-builder.js';

export function generateAlchemyConfig(config: AlchemyConfig): string {
  const builder = new TypeScriptBuilder();

  // Add header comment
  builder.addBlockComment([
    'Alchemy Configuration',
    'Generated by alchemy-migrator',
    `Generated at: ${new Date().toISOString()}`,
    '',
    'Learn more: https://alchemy.run',
  ]);

  builder.addLine();

  // Add imports
  builder.addImport({ default: 'alchemy', from: 'alchemy' });

  const resourceTypes = new Set(config.resources.map(r => r.type));
  if (resourceTypes.size > 0) {
    builder.addImport({
      named: Array.from(resourceTypes),
      from: 'alchemy/cloudflare'
    });
  }

  builder.addLine();
  builder.addLine();

  // Initialize app
  builder.addComment('Initialize Alchemy app');
  const appInit = config.stage
    ? `alchemy("${config.appName}", { stage: "${config.stage}" })`
    : `alchemy("${config.appName}")`;
  builder.addConstDeclaration('app', `await ${appInit}`, false);

  builder.addLine();
  builder.addLine();

  // Add resources
  if (config.resources.length > 0) {
    builder.addComment('Define resources');
    builder.addLine();

    for (const resource of config.resources) {
      generateResource(builder, resource);
      builder.addLine();
    }
  }

  // Add workers
  if (config.workers.length > 0) {
    builder.addComment('Define workers');
    builder.addLine();

    for (const worker of config.workers) {
      generateWorker(builder, worker, config);
      builder.addLine();
    }
  }

  // Add finalize
  builder.addComment('Clean up orphaned resources');
  builder.addLine('await app.finalize();');

  return builder.build();
}

function generateResource(builder: TypeScriptBuilder, resource: AlchemyResource): void {
  const props = { ...resource.props };

  // Add adopt flag if not already present
  if (resource.adopt && !props.adopt) {
    props.adopt = true;
  }

  const propsStr = builder.addObjectLiteral(props, true);

  if (resource.type === 'DurableObjectNamespace') {
    // DurableObjectNamespace is NOT awaited
    builder.addConstDeclaration(
      resource.variableName,
      `${resource.type}("${resource.id}", ${propsStr})`,
      true
    );
  } else {
    builder.addAwaitConstDeclaration(
      resource.variableName,
      `${resource.type}("${resource.id}", ${propsStr})`,
      true
    );
  }
}

function generateWorker(
  builder: TypeScriptBuilder,
  worker: AlchemyWorker,
  config: AlchemyConfig
): void {
  const props: any = { ...worker.props };

  // Add bindings
  if (Object.keys(worker.bindings).length > 0) {
    const bindings: Record<string, any> = {};

    for (const [key, binding] of Object.entries(worker.bindings)) {
      switch (binding.type) {
        case 'resource':
          bindings[key] = `$ref:${binding.resourceRef}`;
          break;
        case 'secret':
          bindings[key] = `$ref:alchemy.secret(process.env.${binding.secretName})`;
          break;
        case 'plainText':
          bindings[key] = binding.value;
          break;
        case 'json':
          bindings[key] = binding.value;
          break;
      }
    }

    props.bindings = bindings;
  }

  // Add routes
  if (worker.routes && worker.routes.length > 0) {
    props.routes = worker.routes;
  }

  // Add crons
  if (worker.crons && worker.crons.length > 0) {
    props.crons = worker.crons;
  }

  // Add event sources
  if (worker.eventSources && worker.eventSources.length > 0) {
    props.eventSources = worker.eventSources.map(es => ({
      queue: `$ref:${es.queueRef}`,
      settings: es.settings,
    }));
  }

  const propsStr = builder.addObjectLiteral(props, true);

  builder.addAwaitConstDeclaration(
    worker.variableName,
    `Worker("${worker.id}", ${propsStr})`,
    true
  );
}
